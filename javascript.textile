Topics
* Javascript
* Node/NPM
* Modules
* Public Modules
* Webpack
* Webpack Server
* Webpack Transpilers
* React
* React Components/Modules
* Managing State
* Styling

Javascript
* Interpreted (Lesson1)
* Functions are values
* const vs non-const
* Weakly-typed
* Globals and scope (Lesson2)
* let vs var (Lesson3)

Node/NPM
* Node - execution environment and module system for javascript
* NPM - built on top of Node to manage Node modules and run Node commands
* Installation - nvm (multiple versions of node/npm).
* Demo project - 'npm init' (Lesson4)
** nodeclipse -p
** package.json
** Adding a 'start' script.

Node Modules (Lesson5)
* Make a local module ('const' and 'let' in modules).
* Reference using the require() function.
* 'require' does the following:

<code>(function (exports, require, module, __filename, __dirname) {
  // YOUR CODE INJECTED HERE!
});</code>

Public modules (Lesson6)
* Adding a public module 'npm install moment --save', 'npm update'
* Rating npm modules by usage:  "npmjs":https://www.npmjs.com/

Webpack (Lesson7)
* Node/NPM are great at integrating multiple javascript libraries.
* Now, make it work for a web browser:
** Start from an anchor javascript file (i.e. index.js).
** 'Run' the anchor in node, but hook the 'require()' function and keep track of the referenced javascript files (the root one, any it brings in with require() statements, any the included modules bring in with require() statements).
** Combine the tracked javascript files into a single bundle that you can reference from a web page.
* Webpack
** npm install webpack webpack-cli --save-dev (npm update -D)
** webpack.config.js

Webpack Server (Lesson8)
* If webpack can make a bundle, it can also make an 'in-memory' version of the bundle.
* If webpack can find your sources starting with an anchor, it can also 'watch' these sources and rebuild the 'in-memory' bundle as needed.
* npm install webpack-serve --save-dev (npm update -D)
* Demo
** Hot-reload
** Source-debugging

Webpack Transpilers (Lession9)
* Desire to use 'newer' javascript (and CSS)
** Browsers are slow to change.
* Transpilation
** User newer javascript syntax, newer files (scss for SASS vs. css for CSS).
** Convert newer syntax, files to older javascript/css format.
** Since webpack knows about our sources from 'require' statements, it knows what needs to be transpiled.
* Use the latest javascript
** npm install --save-dev babel-core babel-loader babel-preset-env babel-preset-stage-2 (npm update -D)
** Review changes
*** Babel configuration in package.json
*** Babel reference in webpack.config.js
*** mode and devtool changes
*** Debugger changes (webpack-internal)

React
* Javascript library
* Sits between your application and DOM
** State model
** Javascript application makes updates to state model (javascript = fast).
** State model changes inspire DOM changes (slow).
* Demo (Lession10)
** npm install --save react react-dom (npm update)
* JSX (Lession11)
** npm install --save-dev babel-preset-react (npm update -D)

React components/modules (Lesson12)
* Package directory name.
** index.jsx and others (later)
* Functional components
** Why you need 'import React...'.
** Add a property live.
* React hot module replacement (vs reloading the page) (Lession13)
** npm install --save-dev react-hot-loader (npm update -D)
** Components can be wrapped.
* Class components vs functional components (Lesson14)
** Lifecycle methods
** Internal component state (i.e. open/close state of a combo-box).
** Start with functional components, use class when you need the other capabilities.

Managing State
* You could place state in Component classes - problematic since components have lifecycles and state does not.
* What you want
** A local repository where state is cataloged.
** State should exists as 'snapshots'.  State T2 should be state T1 with replacements of elements that changed.
** State datastructures should be immutable (ImmutableJS).
** State changes should be driven by commands/reducers.
* Redux (Lesson15)
** npm install immutable redux --save (npm update)
** Create the store, reducer, actions.
* Redux + React (Lesson16)
** npm i react-redux --save (npm update)
** Convert class with state to functional component with redux state.
** No converting to toJS() in mapStateToProps
** Hiding ImmutableJS
*** Use selector functions in mapStateToProps that return immutableJS elements.
*** Use a utility method that converts props into a similar object with converted immutableJS elements.

Styling
* You could do everything in the elements themselves.
* Ultimately, you want CSS and minimum dom-hints to style.
* You also want modular styles (similar to the modular problem with javascript).